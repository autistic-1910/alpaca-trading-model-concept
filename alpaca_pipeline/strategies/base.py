"""Base strategy class and related components."""

import uuid
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
import pandas as pd

from ..config import get_config
from ..utils import get_logger, validate_or_raise
from ..data.models import BarData, PortfolioSnapshot

logger = get_logger(__name__)


class StrategyState(Enum):
    """Strategy execution states."""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"
    STOPPED = "stopped"


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"
    CLOSE_ALL = "close_all"


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""
    
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    symbol: str = ""
    signal_type: SignalType = SignalType.HOLD
    quantity: float = 0.0
    price: Optional[float] = None
    confidence: float = 0.0  # 0.0 to 1.0
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal after initialization."""
        if not self.symbol:
            raise ValueError("Symbol is required")
        
        if not isinstance(self.signal_type, SignalType):
            raise ValueError(f"Invalid signal type: {self.signal_type}")
        
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            'signal_id': self.signal_id,
            'symbol': self.symbol,
            'signal_type': self.signal_type.value,
            'quantity': self.quantity,
            'price': self.price,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StrategySignal':
        """Create signal from dictionary."""
        return cls(
            signal_id=data.get('signal_id', str(uuid.uuid4())),
            symbol=data['symbol'],
            signal_type=SignalType(data['signal_type']),
            quantity=data.get('quantity', 0.0),
            price=data.get('price'),
            confidence=data.get('confidence', 0.0),
            timestamp=datetime.fromisoformat(data['timestamp']),
            metadata=data.get('metadata', {})
        )


@dataclass
class StrategyPerformance:
    """Strategy performance metrics."""
    
    total_return: float = 0.0
    annualized_return: float = 0.0
    volatility: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    win_rate: float = 0.0
    profit_factor: float = 0.0
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    largest_win: float = 0.0
    largest_loss: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert performance to dictionary."""
        return {
            'total_return': self.total_return,
            'annualized_return': self.annualized_return,
            'volatility': self.volatility,
            'sharpe_ratio': self.sharpe_ratio,
            'max_drawdown': self.max_drawdown,
            'win_rate': self.win_rate,
            'profit_factor': self.profit_factor,
            'total_trades': self.total_trades,
            'winning_trades': self.winning_trades,
            'losing_trades': self.losing_trades,
            'avg_win': self.avg_win,
            'avg_loss': self.avg_loss,
            'largest_win': self.largest_win,
            'largest_loss': self.largest_loss
        }


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies."""
    
    def __init__(
        self,
        name: str,
        symbols: List[str],
        parameters: Optional[Dict[str, Any]] = None
    ):
        """Initialize base strategy.
        
        Args:
            name: Strategy name
            symbols: List of symbols to trade
            parameters: Strategy-specific parameters
        """
        self.strategy_id = str(uuid.uuid4())
        self.name = name
        self.symbols = symbols
        self.parameters = parameters or {}
        
        # State management
        self.state = StrategyState.INACTIVE
        self.created_at = datetime.now()
        self.started_at: Optional[datetime] = None
        self.stopped_at: Optional[datetime] = None
        
        # Data storage
        self.market_data: Dict[str, pd.DataFrame] = {}
        self.signals: List[StrategySignal] = []
        self.positions: Dict[str, float] = {symbol: 0.0 for symbol in symbols}
        self.portfolio_value_history: List[float] = []
        
        # Performance tracking
        self.performance = StrategyPerformance()
        self.trades: List[Dict[str, Any]] = []
        
        # Configuration
        self.config = get_config()
        
        # Validate parameters
        self._validate_parameters()
        
        logger.info(
            "Strategy initialized",
            strategy_id=self.strategy_id,
            name=self.name,
            symbols=self.symbols
        )
    
    @abstractmethod
    def generate_signals(
        self,
        current_data: Dict[str, BarData],
        portfolio: PortfolioSnapshot
    ) -> List[StrategySignal]:
        """Generate trading signals based on current market data.
        
        Args:
            current_data: Current market data for all symbols
            portfolio: Current portfolio snapshot
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def _validate_parameters(self):
        """Validate strategy-specific parameters."""
        pass
    
    def start(self):
        """Start the strategy."""
        if self.state == StrategyState.ACTIVE:
            logger.warning("Strategy is already active", strategy_id=self.strategy_id)
            return
        
        self.state = StrategyState.ACTIVE
        self.started_at = datetime.now()
        
        logger.info(
            "Strategy started",
            strategy_id=self.strategy_id,
            name=self.name
        )
    
    def stop(self):
        """Stop the strategy."""
        if self.state == StrategyState.STOPPED:
            logger.warning("Strategy is already stopped", strategy_id=self.strategy_id)
            return
        
        self.state = StrategyState.STOPPED
        self.stopped_at = datetime.now()
        
        logger.info(
            "Strategy stopped",
            strategy_id=self.strategy_id,
            name=self.name
        )
    
    def pause(self):
        """Pause the strategy."""
        if self.state != StrategyState.ACTIVE:
            logger.warning(
                "Cannot pause strategy that is not active",
                strategy_id=self.strategy_id,
                current_state=self.state.value
            )
            return
        
        self.state = StrategyState.PAUSED
        
        logger.info(
            "Strategy paused",
            strategy_id=self.strategy_id,
            name=self.name
        )
    
    def resume(self):
        """Resume the strategy."""
        if self.state != StrategyState.PAUSED:
            logger.warning(
                "Cannot resume strategy that is not paused",
                strategy_id=self.strategy_id,
                current_state=self.state.value
            )
            return
        
        self.state = StrategyState.ACTIVE
        
        logger.info(
            "Strategy resumed",
            strategy_id=self.strategy_id,
            name=self.name
        )
    
    def update_market_data(self, symbol: str, bar_data: BarData):
        """Update market data for a symbol.
        
        Args:
            symbol: Symbol to update
            bar_data: New bar data
        """
        if symbol not in self.market_data:
            self.market_data[symbol] = pd.DataFrame()
        
        # Convert bar data to DataFrame row
        new_row = pd.DataFrame([{
            'timestamp': bar_data.timestamp,
            'open': bar_data.open,
            'high': bar_data.high,
            'low': bar_data.low,
            'close': bar_data.close,
            'volume': bar_data.volume,
            'trade_count': bar_data.trade_count,
            'vwap': bar_data.vwap
        }])
        
        new_row.set_index('timestamp', inplace=True)
        
        # Append to existing data
        self.market_data[symbol] = pd.concat([self.market_data[symbol], new_row])
        
        # Keep only recent data to manage memory
        max_bars = self.parameters.get('max_bars_history', 1000)
        if len(self.market_data[symbol]) > max_bars:
            self.market_data[symbol] = self.market_data[symbol].tail(max_bars)
    
    def process_signal(self, signal: StrategySignal):
        """Process a generated signal.
        
        Args:
            signal: Trading signal to process
        """
        # Add signal to history
        self.signals.append(signal)
        
        # Update position tracking
        if signal.signal_type in [SignalType.BUY]:
            self.positions[signal.symbol] += signal.quantity
        elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
            self.positions[signal.symbol] -= signal.quantity
        elif signal.signal_type == SignalType.CLOSE_ALL:
            self.positions[signal.symbol] = 0.0
        
        logger.debug(
            "Signal processed",
            strategy_id=self.strategy_id,
            signal_id=signal.signal_id,
            symbol=signal.symbol,
            signal_type=signal.signal_type.value,
            quantity=signal.quantity
        )
    
    def get_current_position(self, symbol: str) -> float:
        """Get current position for a symbol.
        
        Args:
            symbol: Symbol to check
            
        Returns:
            Current position size
        """
        return self.positions.get(symbol, 0.0)
    
    def get_market_data(self, symbol: str, periods: int = 100) -> pd.DataFrame:
        """Get recent market data for a symbol.
        
        Args:
            symbol: Symbol to get data for
            periods: Number of recent periods to return
            
        Returns:
            DataFrame with market data
        """
        if symbol not in self.market_data:
            return pd.DataFrame()
        
        return self.market_data[symbol].tail(periods)
    
    def calculate_technical_indicators(
        self,
        symbol: str,
        indicators: Optional[List[str]] = None
    ) -> pd.DataFrame:
        """Calculate technical indicators for a symbol.
        
        Args:
            symbol: Symbol to calculate indicators for
            indicators: List of indicators to calculate
            
        Returns:
            DataFrame with technical indicators
        """
        if symbol not in self.market_data or self.market_data[symbol].empty:
            return pd.DataFrame()
        
        df = self.market_data[symbol].copy()
        
        if indicators is None:
            indicators = ['sma_20', 'sma_50', 'rsi_14', 'bb_20']
        
        # Simple Moving Averages
        if 'sma_20' in indicators:
            df['sma_20'] = df['close'].rolling(window=20).mean()
        if 'sma_50' in indicators:
            df['sma_50'] = df['close'].rolling(window=50).mean()
        
        # RSI
        if 'rsi_14' in indicators:
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['rsi_14'] = 100 - (100 / (1 + rs))
        
        # Bollinger Bands
        if 'bb_20' in indicators:
            sma_20 = df['close'].rolling(window=20).mean()
            std_20 = df['close'].rolling(window=20).std()
            df['bb_upper'] = sma_20 + (std_20 * 2)
            df['bb_lower'] = sma_20 - (std_20 * 2)
            df['bb_middle'] = sma_20
        
        return df
    
    def update_performance(self, portfolio_value: float):
        """Update strategy performance metrics.
        
        Args:
            portfolio_value: Current portfolio value
        """
        self.portfolio_value_history.append(portfolio_value)
        
        if len(self.portfolio_value_history) < 2:
            return
        
        # Calculate returns
        returns = pd.Series(self.portfolio_value_history).pct_change().dropna()
        
        if len(returns) == 0:
            return
        
        # Update performance metrics
        self.performance.total_return = (
            (self.portfolio_value_history[-1] / self.portfolio_value_history[0]) - 1
        ) * 100
        
        if len(returns) > 1:
            self.performance.volatility = returns.std() * (252 ** 0.5) * 100  # Annualized
            
            if self.performance.volatility > 0:
                self.performance.sharpe_ratio = (
                    returns.mean() * 252 / (self.performance.volatility / 100)
                )
        
        # Calculate max drawdown
        peak = pd.Series(self.portfolio_value_history).expanding().max()
        drawdown = (pd.Series(self.portfolio_value_history) - peak) / peak
        self.performance.max_drawdown = abs(drawdown.min()) * 100
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy status information.
        
        Returns:
            Dictionary with strategy status
        """
        return {
            'strategy_id': self.strategy_id,
            'name': self.name,
            'state': self.state.value,
            'symbols': self.symbols,
            'created_at': self.created_at.isoformat(),
            'started_at': self.started_at.isoformat() if self.started_at else None,
            'stopped_at': self.stopped_at.isoformat() if self.stopped_at else None,
            'total_signals': len(self.signals),
            'current_positions': self.positions,
            'performance': self.performance.to_dict()
        }
    
    def reset(self):
        """Reset strategy state and data."""
        self.state = StrategyState.INACTIVE
        self.started_at = None
        self.stopped_at = None
        self.signals.clear()
        self.positions = {symbol: 0.0 for symbol in self.symbols}
        self.portfolio_value_history.clear()
        self.trades.clear()
        self.performance = StrategyPerformance()
        
        # Keep market data but clear signals
        for symbol in self.market_data:
            self.market_data[symbol] = pd.DataFrame()
        
        logger.info(
            "Strategy reset",
            strategy_id=self.strategy_id,
            name=self.name
        )
    
    def export_signals(self) -> List[Dict[str, Any]]:
        """Export all signals as list of dictionaries.
        
        Returns:
            List of signal dictionaries
        """
        return [signal.to_dict() for signal in self.signals]
    
    def export_performance(self) -> Dict[str, Any]:
        """Export performance metrics.
        
        Returns:
            Performance metrics dictionary
        """
        return {
            'strategy_info': {
                'strategy_id': self.strategy_id,
                'name': self.name,
                'symbols': self.symbols,
                'parameters': self.parameters
            },
            'performance': self.performance.to_dict(),
            'portfolio_history': self.portfolio_value_history,
            'total_signals': len(self.signals),
            'total_trades': len(self.trades)
        }
    
    def __str__(self) -> str:
        """String representation of strategy."""
        return f"{self.name} ({self.strategy_id[:8]}...) - {self.state.value}"
    
    def __repr__(self) -> str:
        """Detailed string representation of strategy."""
        return (
            f"BaseStrategy(name='{self.name}', "
            f"symbols={self.symbols}, "
            f"state='{self.state.value}', "
            f"signals={len(self.signals)})"
        )